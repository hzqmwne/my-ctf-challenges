# Writeup

## 背景

传统的恶意软件检测主要依赖于静态特征识别，但随着对抗强度的增加，静态特征的泛化效果难以保证。  
现代的反病毒软件、WAF等恶意软件检测场景开始引入模拟执行等方案，无需承担实际执行的风险，同时能够获得样本的动态行为特征，检测效果更佳。  

模拟执行本身具有相当大的实现难度和挑战，以脚本文件为例，甚至很多时候由于工程复杂度、开源许可、性能等条件限制，并不能直接复用官方的解释器，而只能采取自己或第三方的实现。  
但是，不同的解释器实现无法做到所有细节都完全相同，因此在某些边界情况下模拟执行的行为可能与真实执行的行为不同，精心准备的攻击者可以利用这些差异来绕过检测。  

## 设计

本题是对以上场景的一个模拟。  

程序的功能是一个简单的四则运算计算器，支持十进制整数，加、减、乘、除四种运算，以及小括号。程序的真实计算流程使用高精度整数，但最终导出计算结果时只预留了一个int32的空间，因此如果计算结果是一个大整数，在最后一步会产生栈溢出。  
安全审计人员发现了这个漏洞，但是难以推动修复，只好在实际计算前部署一道防护：对表达式先做一次模拟计算，如果在计算过程的任意时刻超出了int32的范围，就认定为风险并拒绝后面的真实执行。  

但是，这个计算器不仅支持C风格的\/\*...\*/的注释，而且能够精准的解析嵌套注释。安全人员实现模拟计算的时候或许忽视了这一点，或许只是为了实现简单能快速上线，因此只支持了贪心的注释解析；同时，为了让模拟计算尽可能的不受非法输入的干扰，对于其中任何无法理解的语法元素都选择了直接忽略。最终，这个带有前置防护的程序当然被黑客毫不留情的攻破了。  

---

代码使用flex实现词法解析、bison实现语法解析。基本词法单元有：\[0-9\]+、"+"、"-"、"\*"、"/"、"("、")"。作为注释起始和结束标记的"/\*"和"\*/"并不会作为词法token返回给语法解析器。  
parser1.l & parser1.y 是第一套解析，在遇到"/\*"时进入注释状态，遇到第一个"\*/"时即退出注释状态，中间的字符忽略。如果遇到孤立的"\*/"，也直接忽略。  
parser2.l & parser2.y 是第二套解析，在遇到"/\*"时进入注释状态，并在后续遇到"/\*"时继续增加计数，遇到"\*/"时减少计数，直到计数为0时才退出注释状态。  

## 解答

根据前后两次解析对嵌套注释处理逻辑的不同，容易发现，对于包含一层嵌套的表达式 "a /\* b /\* c \*/ d \*/ e"，parser1将"/\* b /\* c \*/"识别为注释，同时忽略"d"和"e"之间的孤立"\*/"，有效的词法单元为 \[a d e\]；parser2正常识别出嵌套注释"/\* b /\* c \*/ d \*/"，有效的词法单元为 \[a e\]。  

我们需要构造一个表达式，在parser1的计算全程不超过int32范围，同时允许parser2的计算结果为任意大的任意整数。  

如果只用不超过int32的小整数通过四则运算构造出大整数，比较直观且简短的方案是使用秦九韶算法将其转换为"((a \* b + c) \* d + e) \* f + g ..."形式。  
而两套parser对嵌套注释的解析规则使得可以在parser1中插入额外的词法单元，因此可以在乘法中引入"* 0"使值归零("/\* /\* \*/ \* 0 \*/")，从而通过parser1的int32范围检测。最终构造的表达式格式形如 "((a /\* /\* \*/ \* 0 \*/ \* b + c) /\* /\* \*/ \* 0 \*/ \* d + e) /\* /\* \*/ \* 0 \*/ \* f + g ..."。  

通过parser1的检测后，表达式parser2的计算结果会以小端序字节溢出写到栈上，从而能够实现栈上任意可控的溢出。  
后续的栈溢出部分则非常简单，程序没有开启PIE和Stack Canary，且存在"pop rdi ; ret"和"pop rsi ; ret"两个gadget恰好可以控制前两个参数，通过ROP调用__printf__chk输出GOT表保存的地址泄露libc基址，再跳到main重新进入程序，ROP调用libc的system("/bin/sh")即可完成利用。  
详细可参考 [exp.py](./exp.py ) 。  

## 其他

- 此题最初设想作为PWN & Reverse双分类题，且更偏向于Reverse，因为主要难点确实是在发现两次parser的不同之处，外面的ROP PWN只是套个皮，以带入背景中的场景。不过最后还是归类到了纯PWN。  
- 在确定以嵌套注释处理差异作为题目漏洞点后，曾思考能否避免孤立"\*/"的存在(毕竟强行忽略它很不优雅)，但遗憾的是，任意合法的嵌套注释，在非嵌套的贪婪解析下，必然在后面存在孤立的"\*/"。  
- 坦诚说明，除了题目设计思路以及main函数的实现，此题其他部分几乎完全由GPT-5.1-Codex-Max模型完成（包括两套解析器和大数运算的实现），对目前大模型的能力深表感叹。  
- 你在程序中找不到任何有用的字符串(包括flex/bison通常固定包含的)，这是有意去除的。同时，程序开启了"-O3 -flto"等高级别优化并strip全部符号、二进制命名为pwn、banner和题目描述没有多余的话，这也是为了避免通过意外的方式泄露程序的信息。你只能通过分析代码来获知程序的逻辑！  
- 这也是试图稍微贴合的一点现实软件：代码多且逻辑复杂、优化级别高、不一定存在加壳混淆、减少无意义但泄露信息的字符串等  
- 尽管如此，结合ida-pro-mcp，GPT-5.1还是能瞬间从无符号的程序中判断出这是大数运算且支持四则运算和括号，且能立刻找到栈溢出的所在位置；进一步允许模型运行程序，Claude-4.5-Opus发现了"/\*...\*/"注释语法且注意到两个解析器的不同。不过或许是我后面的提示词不够好，模型没有构造出令程序Crash的输入。  
- 我忽略了Fuzz，没有想到AFL能轻松找到Crash。虽然出题时我并没有假定解题方向，但预想可能是硬逆逻辑或者调试词法返回的token或者脑电波同频直接猜到嵌套注释。  
- 算是吃了vide coding的果，原本设计中parser1不仅要拒绝计算过程中的int32溢出，还要拒绝原始数字字面量的int32溢出。可能是提示词没有强调后者，在拿到程序后只测了直接输入大整数，却没有测试大整数 \* 0会不会报错（p.s.没测的东西多了去了，也不只有这个）。如果这个限制也生效，或许AFL将更难成功？  
- 关PIE和Stack Canary，是因为我没有太考虑开启PIE后如何利用，通常来说第一步只有Partial Overwrite返回地址期望跳到一个print能带出地址信息同时能再次接收输入，但在这个程序中似乎很难找到这样的位置。不知道开启PIE后是否有可行的利用方法。  
